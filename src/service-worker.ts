import { precacheAndRoute } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from "workbox-strategies";
import { ExpirationPlugin } from "workbox-expiration";

// self.__WB_MANIFEST is injected by Vite/Workbox during build
declare let self: ServiceWorkerGlobalScope & { __WB_MANIFEST: unknown };

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST || []);

// Cache static assets (images, fonts, etc) with long-term caching
registerRoute(
  ({ request }) => 
    request.destination === "image" || 
    request.destination === "font" ||
    request.destination === "style" ||
    request.destination === "script",
  new CacheFirst({
    cacheName: "static-assets-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  }),
);

// Cache JSON data files with network-first strategy for freshness
registerRoute(
  ({ url }) => 
    url.pathname.includes("/programme/") && url.pathname.endsWith(".json"),
  new NetworkFirst({
    cacheName: "data-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
);

// Cache API requests with stale-while-revalidate
registerRoute(
  ({ url }) => url.pathname.startsWith("/api/"),
  new StaleWhileRevalidate({
    cacheName: "api-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
);

// Handle navigation requests with network-first strategy
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: "navigation-cache",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
      }),
    ],
  }),
);

// Listen for manual refresh requests from the app
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'REFRESH_DATA') {
    // Clear data caches to force fresh fetch
    caches.delete('data-cache').then(() => {
      // Notify the app that cache has been cleared
      event.ports[0]?.postMessage({ type: 'DATA_CACHE_CLEARED' });
    });
  }
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Show a notification when a new version is available
self.addEventListener('activate', (event) => {
  // Clean up old caches
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => 
            cacheName.startsWith('data-cache-') && 
            !cacheName.includes('v1.0.0')
          )
          .map((cacheName) => caches.delete(cacheName))
      );
    })
  );
  
  // Take control of all clients immediately
  return self.clients.claim();
});
